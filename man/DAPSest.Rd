% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DAPSest_function.R
\name{DAPSest}
\alias{DAPSest}
\title{Fitting DAPSm with fixed or optimal weight}
\usage{
DAPSest(dataset, out.col = NULL, trt.col = NULL, caliper = 0.1,
  weight = "optimal", coords.columns = NULL, pairsRet = FALSE,
  cov.cols = NULL, cutoff = 0.1, w_tol = 0.01, coord_dist = FALSE,
  distance = StandDist, caliper_type = c("DAPS", "PS"), quiet = FALSE,
  true_value = NULL, matching_algorithm = c("optimal", "greedy"),
  remove.unmatchables = FALSE)
}
\arguments{
\item{dataset}{Data frame including treatment, outcome, coordinates, propensity score
estimates (named prop.scores) and observed confounders.}

\item{out.col}{If outcome column name is not 'Y', out.col should be the index of the outcome
column.}

\item{trt.col}{If treatment is not named 'X', trt.col should be set to the index of the
treatment column.}

\item{caliper}{A caliper for the DAPS Score difference of matched pairs. Defaults to 0.1.}

\item{weight}{Scalar between 0 and 1 or should be set to 'optimal'. Describes the percent
of weight to be given on PS difference. 1 - weight is given to standardized
distance. If set to 'optimal', the 'optimal' weight is chosen. Defaults to
'optimal'.}

\item{coords.columns}{If the columns of coordinates are not named 'Longitude' and 'Latitude',
coords.columns are the column indices corresponding to longitude and latitude
accordingly.}

\item{pairsRet}{Whether we want to return the information on the matched pairs. Logical.
Defaults to FALSE.}

\item{cov.cols}{If the weight is set to 'optimal', standardized difference of means will be
calculated on the columns whose indices are in cov.cols. If the weight is set
to a numeric value, then cov.cols can be left NULL, or it can be used if we
want the function to return the standardized difference of means of the columns
with indices in cov.cols.}

\item{cutoff}{The cutoff of standardized difference of means under which the covariates are
considered balanced. Defaults to 0.1.}

\item{w_tol}{Tolerance on the choice of the optimal weight. Only needed when weight is
'optimal'. Defaults to 0.01.}

\item{coord_dist}{Set to true when we want to use a distance function that calculates the
spherical distance of points instead of Euclidean. Defaults to FALSE.}

\item{distance}{Function that takes in the distance matrix and returns the standardized
distance matrix. Defaults to the funcion that subtracks the minimum and
divides by the range.}

\item{caliper_type}{Whether we want the caliper to be on DAPS or on the PS. caliper_type must be
either 'DAPS', or 'PS'.}

\item{quiet}{Whether we want to print the choice of weight in DAPS optimal. Defauls to TRUE.}

\item{true_value}{Numeric. If provided, an indicator of whether the CI covers the true value is
returned.}

\item{matching_algorithm}{Argument with options 'optimal', or 'greedy'. The optimal choice uses the optmatch R
package to acquire the matches based on propensity score difference and a caliper on
distance. The greedy option matches treated and control units sequentially, starting
from the ones with the smallest propensity score difference. Defaults to 'optimal'.}

\item{remove.unmatchables}{Logical. Argument of the optmatch function. Defaults to
FALSE. If set to FALSE, the matching fails unless all treated units are matched. If
set to TRUE, matching might return matches only for some of the treated units.}
}
\value{
A list including: the estimate of the causal effect, and potential
standardized difference of means, optimal weight chosen, information on matched
pairs.
}
\description{
Function that fits DAPS by choosing the 'optimal' weight, or using the weight
specified and returns the causal effect estimate under a specification of
caliper. If the weight is set to 'optimal', the optimal weight is chosen as
the smallest weight that satisfies standardized difference less than a cutoff.
For computational reasons, we do not fit DAPS on a lot of weights, but perform
an iterative algorithm to identify the optimal w.
}
\examples{
data('toyData')
toyData$prop.scores <- glm(Z ~ X1 + X2 + X3 + X4, family = binomial,
                           data = toyData)$fitted.values
daps1 <- DAPSest(toyData, out.col = 2, trt.col = 1, caliper = 0.5,
                 weight = 'optimal', coords.columns = c(4, 5),
                 pairsRet = TRUE, cov.cols = 6:9, cutoff = 0.1,
                 w_tol = 0.001, coord_dist = TRUE, caliper_type = 'DAPS',
                 matching_algorithm = 'greedy')
names(daps1)

# Trying for a different value of the caliper
daps2 <- DAPSest(toyData, out.col = 2, trt.col = 1, caliper = 0.1,
                 weight = 'optimal', coords.columns = c(4, 5),
                 pairsRet = TRUE, cov.cols = 6:9, cutoff = 0.1,
                 w_tol = 0.001, coord_dist = TRUE, caliper_type = 'DAPS',
                 matching_algorithm = 'greedy')
names(daps2)
daps1$weight
daps2$weight
}
