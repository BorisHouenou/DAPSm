% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DAPS_functions.R
\name{DAPSopt}
\alias{DAPSopt}
\title{DAPSm with optimal weight
Function that chooses the optimal weight and fits DAPSm.}
\usage{
DAPSopt(dataset, caliper, coords.cols, cov.cols, cutoff = 0.1,
  trt.col = NULL, w_tol = 0.01, distance = StandDist,
  caliper_type = c("DAPS", "PS"), quiet = FALSE, coord_dist = FALSE)
}
\arguments{
\item{dataset}{Data frame including treatment, outcome, coordinates, observed confounders,
and propensity score estimates as 'prop.scores'.}

\item{caliper}{A caliper for the DAPS Score difference of matched pairs. Defaults to 0.1.
Scalar.}

\item{coords.cols}{If the columns of coordinates are not named 'Longitude' and 'Latitude',
coords.columns are the column indices corresponding to longitude and latitude
accordingly.}

\item{cov.cols}{If the weight is set to 'optimal', standardized difference of means will be
calculated on the columns whose indices are in cov.cols.}

\item{cutoff}{The cutoff of standardized difference of means under which the covariates are
considered balanced. Specify when weight is set to 'optimal'. Defaults to 0.1.}

\item{trt.col}{The index of the column in the dataset including the binary
treatment. Necessary when the column is not named 'X'.}

\item{w_tol}{Tolerance on the choice of the optimal weight. Only needed when weight is
'optimal'. Defaults to 0.01.}

\item{distance}{Function te takes in the distance matrix and returns the standardized distance
matrix. Defaults to the function that subtracks the minimum and divides by the
range.}

\item{caliper_type}{Whether we want the caliper to be on DAPS or on the PS. caliper_type must
either be 'DAPS', or 'PS'.}

\item{quiet}{Whether we want to print the performance of weights.}

\item{coord_dist}{Set to true when we want to use a distance function that calculates the
spherical distance of points instead of Euclidean. Defaults to FALSE.}
}
\value{
List of weight chosen, matched dataset, standardized difference of
the columns in cov.cols, indices of matched treated and controls.
}
\description{
DAPSm with optimal weight
Function that chooses the optimal weight and fits DAPSm.
}
\examples{
data('toyData')
toyData$prop.scores <- glm(Z ~ X1 + X2 + X3 + X4, family = binomial,
                           data = toyData)$fitted.values
daps_opt <- DAPSopt(toyData, caliper = 0.5, coords.cols = c(4, 5),
                    cov.cols = 6:8, trt.col = 1)
class(daps_opt)
names(daps_opt)
}

